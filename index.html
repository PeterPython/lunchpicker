<!-- Roulette Wheel Script -->
<script>
  window.addEventListener("DOMContentLoaded", function() {
    // Returns an array of names from the attendance table for those who clicked "Yes"
    function getAttendingNames() {
      const rows = document.querySelectorAll("#attendanceTable tbody tr");
      const names = [];
      rows.forEach(row => {
        const name = row.cells[0].textContent.trim();
        const yesRadio = row.querySelector(`input[name="officeStatus_${name}"][value="yes"]`);
        if (yesRadio && yesRadio.checked) {
          names.push(name);
        }
      });
      console.log("Attending names:", names);
      return names;
    }
    
    const rouletteCanvas = document.getElementById("rouletteWheel");
    const rouletteCtx = rouletteCanvas.getContext("2d");
    const rouletteCenterX = rouletteCanvas.width / 2;
    const rouletteCenterY = rouletteCanvas.height / 2;
    const rouletteRadius = Math.min(rouletteCenterX, rouletteCenterY) - 20;
    
    let rouletteCurrentAngle = 0;
    let currentAttendees = []; // Names used in the current spin.
    let currentSectorAngle = 0;
    let isSpinning = false; // Prevent starting multiple spins at once.
    
    // Draws the roulette wheel with each sector having a unique color.
    function drawRouletteWheel(attendees) {
      rouletteCtx.clearRect(0, 0, rouletteCanvas.width, rouletteCanvas.height);
      if (attendees.length === 0) {
        rouletteCtx.font = "20px Arial";
        rouletteCtx.textAlign = "center";
        rouletteCtx.fillText("No attendees selected", rouletteCenterX, rouletteCenterY);
        return;
      }
      const sectors = attendees.length;
      const sectorAngle = 2 * Math.PI / sectors;
      
      for (let i = 0; i < sectors; i++) {
        const hue = i * (360 / sectors);
        rouletteCtx.fillStyle = `hsl(${hue}, 80%, 50%)`;
        
        const startAngle = rouletteCurrentAngle + i * sectorAngle;
        const endAngle = startAngle + sectorAngle;
        rouletteCtx.beginPath();
        rouletteCtx.moveTo(rouletteCenterX, rouletteCenterY);
        rouletteCtx.arc(rouletteCenterX, rouletteCenterY, rouletteRadius, startAngle, endAngle);
        rouletteCtx.closePath();
        rouletteCtx.fill();
        
        // Draw the person's name within the sector.
        rouletteCtx.save();
        rouletteCtx.translate(rouletteCenterX, rouletteCenterY);
        rouletteCtx.rotate(startAngle + sectorAngle / 2);
        rouletteCtx.textAlign = "right";
        rouletteCtx.fillStyle = "#000";
        rouletteCtx.font = "16px Arial";
        rouletteCtx.fillText(attendees[i], rouletteRadius - 10, 10);
        rouletteCtx.restore();
      }
    }
    
    // Redraws the wheel using the current attendance.
    function updateRouletteWheel() {
      const attendees = getAttendingNames();
      drawRouletteWheel(attendees);
    }
    
    // Persist the UI state by listening for changes to "rouletteState/currentAngle."
    function attachRouletteStateListener() {
      const rouletteStateRef = window.firebaseRef(window.db, "rouletteState/currentAngle");
      window.firebaseOnValue(rouletteStateRef, (snapshot) => {
        const angle = snapshot.val();
        if (angle !== null) {
          rouletteCurrentAngle = angle;
          updateRouletteWheel();
        }
      });
    }
    attachRouletteStateListener();
    
    // Initially draw the wheel.
    updateRouletteWheel();
    
    // Spins the wheel and then snaps it so that a sector’s center is aligned with the pointer (at -π/2).
    function spinRouletteWheel(duration = 5000) {
      if (isSpinning) return;
      isSpinning = true;
      console.log("Spin started");
      const attendees = getAttendingNames();
      if (attendees.length === 0) {
        alert("No attendees selected");
        isSpinning = false;
        return;
      }
      currentAttendees = attendees;
      const sectors = currentAttendees.length;
      currentSectorAngle = 2 * Math.PI / sectors;
      
      const startTime = performance.now();
      const initialAngle = rouletteCurrentAngle;
      const totalSpins = 10; // total full rotations
      
      // Main spin animation.
      function animateRoulette(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        rouletteCurrentAngle = initialAngle + easedProgress * totalSpins * 2 * Math.PI;
        drawRouletteWheel(currentAttendees);
        if (progress < 1) {
          requestAnimationFrame(animateRoulette);
        } else {
          // Calculate which sector’s center is closest to the pointer (located at -π/2)
          const pointerAngle = -Math.PI / 2;
          const normalizedAngle = rouletteCurrentAngle % (2 * Math.PI);
          let pointerPos = (2 * Math.PI + pointerAngle - normalizedAngle) % (2 * Math.PI);
          // Use Math.floor so that the sector whose center is aligned wins.
          let winnerIndex = Math.floor(pointerPos / currentSectorAngle) % sectors;
          const desiredCenter = (winnerIndex + 0.5) * currentSectorAngle;
          const targetRotationMod = (2 * Math.PI + pointerAngle - desiredCenter) % (2 * Math.PI);
          const currentMod = rouletteCurrentAngle % (2 * Math.PI);
          let delta = targetRotationMod - currentMod;
          // Force a forward (clockwise) snap.
          if (delta < 0) {
            delta += 2 * Math.PI;
          }
          const finalTargetAngle = rouletteCurrentAngle + delta;
          
          // Snap animation to align the winning sector.
          const snapDuration = 1000;
          const snapStartAngle = rouletteCurrentAngle;
          const snapStartTime = performance.now();
          function animateSnap(nowSnap) {
            const elapsedSnap = nowSnap - snapStartTime;
            const progressSnap = Math.min(elapsedSnap / snapDuration, 1);
            const easedSnap = 1 - Math.pow(1 - progressSnap, 3);
            rouletteCurrentAngle = snapStartAngle + (finalTargetAngle - snapStartAngle) * easedSnap;
            drawRouletteWheel(currentAttendees);
            if (progressSnap < 1) {
              requestAnimationFrame(animateSnap);
            } else {
              window.firebaseSet(window.firebaseRef(window.db, "rouletteState/currentAngle"), rouletteCurrentAngle);
              alert("Winner: " + currentAttendees[winnerIndex]);
              isSpinning = false;
            }
          }
          requestAnimationFrame(animateSnap);
        }
      }
      requestAnimationFrame(animateRoulette);
    }
    
    // Spin the wheel when the canvas is clicked.
    rouletteCanvas.addEventListener("click", function() {
      spinRouletteWheel(5000);
    });
    
    // (Optional) If you want periodic updates outside of the spin animation, you can re-enable this.
    // setInterval(updateRouletteWheel, 2000);
  });
</script>
